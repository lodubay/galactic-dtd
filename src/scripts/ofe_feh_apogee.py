"""
Plot a grid of [O/Fe] vs [Fe/H] panels for APOGEE data. Takes a minute to run.
"""

from pathlib import Path
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.colors import Normalize, LogNorm
from sklearn.neighbors import KernelDensity
from ofe_feh_vice import GALR_BINS, ABSZ_BINS, FEH_LIM, OFE_LIM
from ofe_feh_vice import setup_axes, setup_colorbar
import paths
from utils import import_allStar, apogee_region, scatter_hist

global NBINS
NBINS = 50

def main(cmap='RdPu', verbose=True):
    if verbose:
        print('Importing allStar data...')
    data = import_allStar()
    if verbose:
        print('Plotting 2D histograms...')
    fig, axs = plot_scatter_hist_grid(data)
    if verbose:
        print('Plotting contours...')
    plot_contours(axs, data, cmap=cmap)
    output = paths.figures / 'ofe_feh_apogee.pdf'
    plt.savefig(output, dpi=300)
    plt.close()
    if verbose:
        print('Saved to %s.' % str(output))


def plot_scatter_hist_grid(data):
    """
    Setup a grid of panels and plot a hybrid scatterplot/2D histogram
    of APOGEE data.
    """
    fig, axs = setup_axes(len(ABSZ_BINS)-1, len(GALR_BINS)-1,
                          xlim=FEH_LIM, ylim=OFE_LIM)
    norm = normalize_colorbar(data)
    setup_colorbar(fig, 'gray', norm, label='Number of stars')
    for i, row in enumerate(axs):
        absz_lim = (ABSZ_BINS[-(i+2)], ABSZ_BINS[-(i+1)])
        for j, ax in enumerate(row):
            galr_lim = (GALR_BINS[j], GALR_BINS[j+1])
            subset = apogee_region(data, galr_lim, absz_lim)
            # Scatter plot / 2D histogram
            scatter_hist(ax, subset['FE_H'], subset['O_FE'],
                         xlim=FEH_LIM, ylim=OFE_LIM, nbins=NBINS,
                         vmin=norm.vmin, vmax=norm.vmax)
            # Label axes
            if i == len(axs)-1:
                ax.set_xlabel('[Fe/H]')
            if j == 0:
                ax.set_ylabel('[O/Fe]')
                ax.text(0.1, 0.1, r'$%s\leq |z| < %s$' % absz_lim,
                        transform=ax.transAxes, size=8, va='bottom', ha='left')
            if i == 0:
                ax.set_title(r'$%s\leq R_{\rm{Gal}} < %s$ kpc'% galr_lim)
    return fig, axs


def plot_contours(axs, data, cmap='Greys', linewidths=0.5):
    """
    Add contours of APOGEE abundances to axes.

    Parameters
    ----------
    axs : list of axes
    filename : str
        Path to APOGEE data file
    cmap_name : str
        Name of colormap to apply to contours
    """
    for i, row in enumerate(axs):
        absz_lim = (ABSZ_BINS[-(i+2)], ABSZ_BINS[-(i+1)])
        for j, ax in enumerate(row):
            galr_lim = (GALR_BINS[j], GALR_BINS[j+1])
            path = kde_path(galr_lim, absz_lim)
            if path.exists():
                xx, yy, logz = read_kde(path)
            else:
                subset = apogee_region(data, galr_lim, absz_lim)
                xx, yy, logz = kde2D(subset['FE_H'], subset['O_FE'], 0.03)
                # Scale by total number of stars in region
                logz += np.log(subset.shape[0])
                save_kde(xx, yy, logz, path)
            # Contour levels in log-likelihood space
            levels = np.arange(10, 14, 0.5)
            ax.contour(xx, yy, logz, levels, cmap=cmap, linewidths=linewidths)


def read_kde(path):
    """
    Read a text file generated by save_kde()
    """
    arr2d = np.genfromtxt(path)
    nrows = int(arr2d.shape[0]/3)
    xx = arr2d[:nrows]
    yy = arr2d[nrows:2*nrows]
    logz = arr2d[2*nrows:]
    return xx, yy, logz


def save_kde(xx, yy, logz, path):
    """
    Generate a text file containing the KDE of the given region along with its
    corresponding x and y coordinates.
    """
    with open(path, 'w') as f:
        for arr in [xx, yy, logz]:
            f.write('#\n')
            np.savetxt(f, arr)


def kde_path(galr_lim, absz_lim, savedir='../data/APOGEE/kde'):
    """
    Generate file name for the KDE of the given region.
    """
    filename = 'ofe_feh_r%s-%s_z%s-%s.dat' % (galr_lim[0], galr_lim[1],
                                              absz_lim[0], absz_lim[1])
    return Path(savedir) / filename


def kde2D(x, y, bandwidth, xbins=100j, ybins=100j, **kwargs):
    """Build 2D kernel density estimate (KDE).

    Parameters
    ----------
    x : array-like
    y : array-like
    bandwidth : float
    xbins : complex, optional [default: 100j]
    ybins : complex, optional [default: 100j]

    Other keyword arguments are passed to sklearn.neighbors.KernelDensity

    Returns
    -------
    xx : MxN numpy array
        Density grid x-coordinates (M=xbins, N=ybins)
    yy : MxN numpy array
        Density grid y-coordinates
    logz : MxN numpy array
        Grid of log-likelihood density estimates
    """
    # create grid of sample locations (default: 100x100)
    xx, yy = np.mgrid[x.min():x.max():xbins,
                      y.min():y.max():ybins]

    xy_sample = np.vstack([yy.ravel(), xx.ravel()]).T
    xy_train  = np.vstack([y, x]).T

    kde_skl = KernelDensity(bandwidth=bandwidth, **kwargs)
    kde_skl.fit(xy_train)

    # score_samples() returns the log-likelihood of the samples
    logz = kde_skl.score_samples(xy_sample)
    return xx, yy, np.reshape(logz, xx.shape)


def normalize_colorbar(data):
    subset = apogee_region(data,
                           galr_lim=(GALR_BINS[2], GALR_BINS[3]),
                           absz_lim=(ABSZ_BINS[0], ABSZ_BINS[1]))
    H, xedges, yedges = np.histogram2d(subset['FE_H'], subset['O_FE'],
                                       bins=NBINS,
                                       range=[FEH_LIM, OFE_LIM])
    norm = LogNorm(vmin=10, vmax=H.max())
    return norm


if __name__ == '__main__':
    main()
